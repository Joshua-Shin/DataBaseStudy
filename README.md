DataBase 학습을 기록하기 위한 저장소 입니다.
---------------
- 개괄
  - DDL(스키마 조작하는거), DML(인스턴스 조작하는거) DCL(접근권한 조작), TCL(트랜젝션 권한 조작)
  - 스키마, 인스턴스. 테이블에서 맨 윗 열을 스키마로 보고, 그 아래 모든 열들을 인스턴스로 보면 돼.
  - DB 설계 = DB 모델링 : 스키마를 만드는것
  - DB 설계의 4단계 : 요구사항분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계
  - 요구사항분석 : 어떤 엔티티를 끌어내야 하는지 업무기술서 같은거 보면서 분석하는거.
  - 개념적 설계 : ERM(=개체 관계 모델), ERD(=개체 관계 다이어그램) 만들기. R은 Relationship.
  - 논리적 설계 : Relational Model 만들기, 테이블을 만든다 생각하면 돼.

- 개념적 설계
  - 엔티티, 관계, 속성
  - 엔티티는 물리적객체 개념적객체를 다 포함한 하나의 정보 단위. 우리나라말로 개체.
  - 속성은 엔티티도 관계도 다 갖고 있을 수 있어.
  - 속성에는 singleValued, multiValued, simple, composite, stored, derived 가 있어
  - Composite 속성의 예는 주소.
  - 차수. degree. 는 unary, binary, tenary.. n-ary 가 있음 하나의 관계에 여러 엔티티가 달려있는거.
  - 대응수. 는 일대일 일대다 다대다. 관계에 매달린 속성은 일대다에서 다 쪽으로 붙일 수 있음
  - 키 속성이 없는 개체를 약한 개체라고 함. Identifying Entity의 키 속성과 약한 개체의 키인 부분 키와 합쳐서 키 속성을 만들 수 있어.
  - 보통은 약한개체는 안만드는게 좋아
  - 상속과 비슷한 개념인데 일반화 라는게 있어.

- 논리적 설계
  - 4가지 제약
    - 도메인 제약, 키 제약, 개체 무결성 제약, 참조 무결성 제약
    - 도메인 제약: 나이 속성에다가 문자열을 쓴다거나 200을 넘기는 수가 들어간다거나 하면 안된다.
    - 키 제약 : 키가 있어야 한다.
    - 개체 무결성 제약 : 키에 해당되는 인스턴스 값은 not null & unique 해야 한다.
    - 참조 무결성 제약 : 참조하는 값이 null 이거나, null이 아니라면 해당 값이 실제로 존재해야 한다.
  - ERD to RM의 7가지 스탭
    - 강한 개체 테이블 만들고
    - 약한 개체 테이블 만들고
    - 1:N 관계인거 1인 릴레이션의 PK를 N인 릴레이션으로 넘겨서 FK 필드 만들어주고
    - 1:1 관계인거 아무쪽에다가 FK 필드 만들어주고
    - N:M 관계인거 새로 테이블 만들어주고 각각의 PK를 가져와서 새 테이블의 Composite Key로 만듦
    - N-Ary 관계인거 새로 테이블 만들어주고 역시 N차 M차인애들의 PK를 새 테이블의 Composite Key로 만들고, 1차인애늬 PK는 그냥 속성으로 포함.
    - multivalued 속성 따로 테이블 만들어주고
  - ERD 아무리 잘 만들었어도 실수 있을 수 있어, ERD를 RM 으로 바꾸는거에는 실수 있으면 안되고, 자동화툴도 있을정도니.
  - 테이블 잘 만들었나 보고 잘못 만들었으면 수정하고, 하는 과정을 정규화라고 하고
  - 정규화의 과정중 핵심은 함수적 종속성을 확인하는거.
  - 현재 테이블에 있는 Key 이외의 다른 속성이 또 다른 속성들을 결정짓고 있다면 테이블을 분리하는것을 고려해야돼.
  - 제3정규화 정도가 이론적으로도 실무적으로도 적합함.
  
- 세팅
  - Oracle, SQL Developer 사용.
  - 맥에서는 Oracle 설치 못함. -> Docker 사용해서 Oracle 설치
  - 맥 m1에서는 Docker로 oracle 컨테이너 생성 및 설치 못함
  - 오픈 소스 컨테이너 런타임인 Colima를 사용해 oci-oracle-xe 이미지를 x86/64 환경으로 띄워서 설치
  - 그러니까 Docker Desktop으로 컨테이너에 설치한게 아니라 Colima로 설치한거임. 다만 Docker Engine은 사용하고 있는 상태인듯.
  - 실제로 Docker Desktop 실행해보면 컨테이너와 이미지 리스트에 oracle 안보임.
  - SQL Developer는 쉽게 설치 가능.
  - Oracle이 사용 가능 상태 되면, SQL developer 실행해서 oracle과 연동.
  - SQL developer를 종료할때 commit할래 물어보는데, commit하면, 컨테이너에 데이터가 저장되는듯.
  - 당연히 새로운 컨테이너 만들어서 다시 시작하면 해당 데이터는 없겠지.
  - 터미널 종료 해도 컨테이너는 자동 종료 안됨. 컴 종료해야 자동 종료 되는듯?
  - 터미널에서 docker ps -a 치면 컨테이너 리스트과 실행상태 볼 수 있음
  - docker stop 컨테이너ID, docker start 컨테이너ID
  - 당연히 컨테이너에서 실행중인 상태여야 sql developer에서 접속 가능해.
  - 컴 종료 후에 다시 시작하는 법
    - colima 시작 : colima start --memory 4 --arch x86_64
    - 종료된 컨테이터 조회 : docker ps -a 
    - docker start CONTAINER_ID
    - 10초후 sql developer 실행
  - [참조](https://shanepark.tistory.com/400)

- 데이터 모델링의 이해
  - 이론에서는 개념적 설계는 ERD 그리는거고, 논리적 설계는 스키마 및 테이블을 만드는거였는데,
  - 실무에서는 개념적 설계나 논리적 설계의 구분이 좀 모호하고, 물리적 설계 단계에서 테이블을 만들게 됨
  - 차이의 주요한 원인은 ERD를 그리는 방식 때문인듯. 
  - 이론에서는 peter chen 방식을 쓰고, 사실 이는 테이블로 옮기기에 변경해야 될 사항들이 좀 많아.
  - 실무에서는 IE 방식 (= crow's foot)을 쓰고 이는 이미 테이블의 스키마 내용을 다 명시하고 있는거나 마찬가지라, 개념적 설계 논리적 설계 구분이 모호.
  - peter chen 에서 사용한 다이아몬드 모양으로 그린 관계에는 속성이 붙을 수 있으나, IE에는 관계에는 속성이 안붙어. 다이아몬드 모양으로 따로 만들지도 않고.
  - 일대다, 일대일에서는 일의 반대편으로 일의 PK를 넘겨. 만약 관계에 속성이 붙었다면, 해당 속성은 같은 방향으로 넘어가.
  - 다시 말해서 일이 있는쪽을 부모 엔티티, 일의 반대쪽을 자식 엔티티라 하고, 부모 엔티티의 PK가 자식 엔티티의 새로운 필드로 들어가면서 FK라 표기하게 됨.
  - 이때 FK가 자식 식별자의 PK가 되어버린다면, 이를 식별자관계라 하고, 그렇지 않다면 비식별자관계라 함.
  - 식별자 관계일때는 부모엔티티가 없다면 자식엔티티도 없게 되겠지. 강한 의존관계.
  - 자식 식별자가 고유의 ID를 새로 만들어서 식별자 관계였던것을 비식별자 관계로 만들 수도 있어.
  - 현재 듣고 있는 인프런 JPA 강의 보면 엔티티 마다 다 고유의 ID값을 주는걸 봐서는 실무에서는 비식별자관계를 많이 사용하는듯.
  - 다만, 이럴 경우 조회할때 조인을 많이 해서 성능의 이슈가 생길 수도 있어
  - 물론, 식별자 관계로만 이어가면 식별자가 composite으로 계속 쌓이고 쌓여서 이것도 문제가 생길 수 있고.
  - 실무에서는 다대다 관계는 무조건 새로운 테이블 만들어서 푸는듯

- 데이터 모델과 성능
  - 정규화 반정규화
  - 비정규화는 아직 정규화를 하지 않은 상태이고,
  - 반정규화는 정규화 해놓은걸 성능 이슈 때문에 다시 돌리는거야.
  - 반정규화를 한다고 해서 꼭 정규형 수치가 낮아지는건 아니고, 넓은 의미에서는 정규화가 아닌, 테이블 구조 변경을 말하기도 하는듯.
  - 예를 들어 테이블 수직 분할. 딱히 정규형이 낮아지는것이 아닌데도 반정규화 종류중 하나임.
  - 성능 이슈는 삽입 갱신 삭제에서 나타나지 않고, 상황에 따라 조회할때 나타남
  - 너무 정규화된 상태면 조인을 여러번 해야된다든지 계산을 계속해야된다든지 하는 이유 때문에 생길 수 있어
  - 정규화 되지 않은 테이블에는 이상 현상. 삽입, 삭제, 갱신 이상이 나타날 수 있어.
  - 함수적 종속성을 확인하고, 부분함수 종속을 제거하는것을 2차 정규화, 이행함수 종속을 제거하는것을 3차 정규화라 함
  - 부분함수 종속은 composite key일때 발생할 수 있는데, 각 키가 결정 짓는 속성들이 다를때를 말함. 이때 각각의 테이블로 분할 할 수 있어
  - 이행함수 종속은 key도 아닌 녀석이 다른 속성을 결정짓고 있을때를 말함. 이때도 테이블 분할.
  - 반정규화를 하기전에, 트렌젝션이나 이런저런것들을 분석하고 검토한뒤, index 조정을 하기도 하고 이런저런걸 한뒤, 안되면 하는거야.
  - 칼럼과 테이블을 중복 저장, 병합, 테이블 수직 분할, 수평분할 등등의 방식이 있어.
  - 테이블에서 PK의 경우 Index 테이블이 자동으로 만들어지고 트리 구조로 저장되기에 순서가 정렬되어있어.
  - PK가 composite key일 경우 어떤 요소를 먼저 두나에 따라 정렬 우선순위가 정해짐. 
  - 따라서, 조회를 많이 하는 애를 composite key중 위로 두는게 좋아
  - FK로 조회를 많이 한다면, 해당 FK의 index 테이블을 수동으로 만드는 방법도 있어.
  - 다대다로 연결되어있을때, 이를 1대다 다대1로 풀어내기 위해 새로운 엔티티를 만들잖아 그걸 연관엔티티
  
- SQL 기본 DML
  - desc 테이블명
  - select from where order by
  - distinct 칼럼명. 중복 제거 해서 보여줌. 
  - =, !=, and, or, not, between a and b, in(a, b), like '%석'
  - insert
  - insert all은 언제나 select 문과 같이 쓰이기에 맨 마지막에 껍데기 select 문을 같이 넣어줘야해.
  - ```
    insert into 테이블명(칼럼명1, 칼럼명2, 칼럼명3) values(칼럼1값, 칼럼2값, 칼럼3값);
   
    insert all into 테이블명(칼럼명1, 칼럼명2, 칼럼명3) values(칼럼1값, 칼럼2값, 칼럼3값) 
               into 테이블명(칼럼명1, 칼럼명2, 칼럼명3) values(칼럼1값, 칼럼2값, 칼럼3값)
    select * from dual
    ```
  - delete from 테이블명 where 조건문
  - update 테이블명 set 칼럼명 = 값 where 조건문
